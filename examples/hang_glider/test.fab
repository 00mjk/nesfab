/*
 * Copyright (c) 2023, Patrick Bene
 * This file is distributed under the Boost Software License, Version 1.0.
 * See LICENSE_1_0.txt or https://www.boost.org/LICENSE_1_0.txt 
 */

// PPUMASK flags:
ct U PPUMASK_GRAYSCALE   = %00000001
ct U PPUMASK_NO_BG_CLIP  = %00000010
ct U PPUMASK_NO_SPR_CLIP = %00000100
ct U PPUMASK_BG_ON       = %00001000
ct U PPUMASK_SPR_ON      = %00010000
ct U PPUMASK_EMPHASIZE_R = %00100000
ct U PPUMASK_EMPHASIZE_G = %01000000
ct U PPUMASK_EMPHASIZE_B = %10000000
ct U PPUMASK_ON          = PPUMASK_BG_ON | PPUMASK_SPR_ON
ct U PPUMASK_NO_CLIP     = PPUMASK_NO_BG_CLIP | PPUMASK_NO_SPR_CLIP

// PPUCTRL flags:
ct U PPUCTRL_NT_2000      = %00000000
ct U PPUCTRL_NT_2400      = %00000001
ct U PPUCTRL_NT_2800      = %00000010
ct U PPUCTRL_NT_2C00      = %00000011
ct U PPUCTRL_VRAM_32_DOWN = %00000100
ct U PPUCTRL_SPR_PT_1000  = %00001000 // Ignored in 8x16 mode.
ct U PPUCTRL_BG_PT_1000   = %00010000
//ct U PPUCTRL_SPR_8x16     = %00100000
ct U PPUCTRL_NMI_ON       = %10000000

// PPUSTATUS flags:
ct U PPUSTATUS_VBLANK        = %10000000
ct U PPUSTATUS_SPR_0         = %01000000
ct U PPUSTATUS_SPR_OVERFLOW  = %00100000


ct Int OAM_Y = 0
ct Int OAM_P = 1
ct Int OAM_A = 2
ct Int OAM_X = 3

ct U NUM_DIR = 9
ct U MAX_DIR = NUM_DIR - 1
ct U MID_DIR = MAX_DIR >> 1
ct U MIN_DIR = 0

ct U PLAYER_Y = 64

vars /game
    UF px = 128.0
    //UF py = 0.0
    UF py_tile = 0.0
    UF pscroll = 0
    UF pspeed = 1.5
    U pscroll_nt = 0

    U pdir = MID_DIR
    U noise_vol = 0
    U held_timer = 0
    Bool rotated = false
    Bool pdead = false

    U[8] score = U[8](0)

vars /oam
    U[256] oam
    : +align

ct U[] plane_patterns = U[]($40, $44, $48, $4C, $1C, $7C, $78, $74, $70)

fn prepare_sprites()
    //do for U i = 0; i != $FF; i += 1
        //oam[i] = $FF

    U i = 0
    do for U x = 0; x != 4; x += 1
        do for U y = 0; y != 3; y += 1
            oam{OAM_X + i} = px.a - 16 + (x << 3)
            oam{OAM_Y + i} = PLAYER_Y - 23 + (y << 3)
            oam{OAM_P + i} = plane_patterns[pdir] + x + (y << 4)
            oam{OAM_A + i} = 0
            i += 4

    do for U i = 0; i != len(score); i += 1
        U j = i << 2
        oam{OAM_X + j + 48} = 152 - (i << 3)
        oam{OAM_Y + j + 48} = 16
        oam{OAM_P + j + 48} = score[i] | $10
        oam{OAM_A + j + 48} = 1

fn upload_oam()
: employs /oam
: +inline
    fence
    {OAMDMA}((&oam).b)


nmi basic_nmi()
    if ready
        ppu_upload_palette()
        ppu_upload_cliff()

        if rotated && !pdead
            {$400F}(0)
            {$4015}(%01000)
            noise_vol = noise_volume_table[pdir]
            {$400E}(noise_pitch_table[pdir])

        {$400C}(noise_vol | %110000)
        if noise_vol != 0
            noise_vol -= 1

    upload_oam()
    {PPUSTATUS}()
    {PPUSCROLL}($00)
    {PPUSCROLL}(pscroll.a)
    {PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP)
    {PPUCTRL}(PPUCTRL_NMI_ON | pscroll_nt)

ct SF[NUM_DIR] hspeed_table =  SF[](-1.0, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1.0)
ct UF[NUM_DIR] vspeed_table =  UF[](1.0, 1.25, 1.5, 1.75, 2.0, 1.75, 1.5, 1.25, 1.0)
ct U[NUM_DIR] noise_pitch_table =  U[](2, 4, 6, 7, 8, 7, 6, 4, 2)
ct U[NUM_DIR] noise_volume_table =  U[](2, 2, 3, 3, 4, 3, 3, 2, 2)

ct U[NUM_DIR] pal2_table =  U[]($26, $26, $26, $36, $30, $37, $26, $26, $26)
ct U[NUM_DIR] pal3_table =  U[]($21, $21, $3C, $30, $3C, $21, $21, $21, $21)

fn move_player()
    if pads[0].pressed & (BUTTON_LEFT | BUTTON_RIGHT)
        held_timer = 3

    if held_timer >= 3
        rotated = false
        if pads[0].held & BUTTON_LEFT && pdir > MIN_DIR
            rotated = true
            pdir -= 1
        if pads[0].held & BUTTON_RIGHT && pdir < MAX_DIR
            rotated = true
            pdir += 1
        held_timer -= 3

    held_timer += 1

    px += UF(hspeed_table[pdir] * pspeed)
    UF sub = UF(vspeed_table[pdir] * pspeed)
    //py -= sub

    py_tile += sub
    if py_tile > 8
        py_tile -= 8
        inc_score()
        update_cliff()

    pscroll += sub
    if(pscroll >= 240)
        pscroll -= 240
        pscroll_nt ^= PPUCTRL_NT_2800

    palette[13] = pal2_table[pdir]
    palette[14] = pal3_table[pdir]

fn collide_player() Bool
    if px < 16
        px = 16
        return true

    if px > (256 - 16)
        px = 256 - 16
        return true

    U i = ((cliff_index + 9) & %11111) >> 1

    if px < (cliffs[i].begin_hole << 3) + 4
        return true

    if px > (cliffs[i].end_hole << 3) - 4
        return true

    return false

data /rlz
    [] title_nt
        file(rlz, "title.nam")

nmi title_nmi()
    {PPUSCROLL}(0)
    {PPUSCROLL}(0)
    {PPUMASK}(PPUMASK_BG_ON)

mode main()
: nmi title_nmi
    palette = game_palette
    ppu_upload_palette()

    {PPUCTRL}(0)
    {PPUMASK}(0)

    {PPUSTATUS}()
    {PPUADDR}($20)
    {PPUADDR}($00)
    ppu_upload_rlz(@title_nt)

    {PPUCTRL}(PPUCTRL_NMI_ON | PPUCTRL_BG_PT_1000)

    while true
        read_pads()
        if pads[0].pressed & BUTTON_START
            break
        nmi

    goto mode game()
    : preserves

ct U[25] game_palette = U[25](
    $11, $2B, $39,
    $13, $21, $3B,
    $15, $23, $31,
    $17, $25, $33,

    $02, $14, $26,
    $04, $16, $28,
    $06, $18, $2A,
    $08, $1A, $2C,

    $0F)

ct U[25] dead_palette = U[25](
    $11, $2B, $39,
    $13, $21, $3B,
    $15, $23, $31,
    $17, $25, $33,

    $02, $14, $26,
    $04, $16, $28,
    $06, $18, $2A,
    $08, $1A, $2C,

    $15)


fn inc_score()
    for U i = 0; i < len(score); i += 1
        if i == 2
            pspeed += 0.0625

        score[i] += 1
        if score[i] == 10
            score[i] = 0
        else
            break

mode game()
: nmi basic_nmi

    {PPUCTRL}(0)
    {PPUMASK}(0)

    palette = game_palette
    ppu_upload_palette()

    load_level()

    for U i = 0; i < len(cliffs); i += 1
        cliffs[i] = Cliff(1, 31)
    // TODO
    //cliffs = Cliff[len(cliffs)](Cliff(1, 30))

    {PPUCTRL}(PPUCTRL_NMI_ON)

    while true
        read_pads()

        if pdead
            palette = dead_palette
        
        else
            move_player()
            pdead = collide_player()

        prepare_sprites()
        //{PPUMASK}(PPUMASK_ON | PPUMASK_NO_CLIP | PPUMASK_GRAYSCALE)
        nmi

    goto mode game()
    : preserves


fn load_level()
    {PPUSTATUS}()
    {PPUADDR}($20)
    {PPUADDR}($00)

    for U y = 0; y < 30; y += 1
        for U x = 0; x < 32; x += 1
            {PPUDATA}($00)

chrrom
    file(fmt, "plane.png") 
    file(fmt, "title.png") 

//ct U CLIFF_WIDTH = 32
//ct U INITIAL_OPEN_WIDTH = CLIFF_WIDTH >> 1
ct U SCROLL_HEIGHT = 60

struct Cliff
    U begin_hole
    U end_hole


vars /game
    U cliff_hole = 4
    U cliff_midpoint = 15
    U cliff_index = 0
    U cliff_y = 30
    Cliff[16] cliffs


fn update_cliff()
    cliff_y += 1

    if cliff_y == SCROLL_HEIGHT
        cliff_y = 0

    cliff_index += 1

    if cliff_index & %1
        return

    U i = (cliff_index & %11111) >> 1

    if cliff_index & %1110
        cliffs[i].begin_hole = 1
        cliffs[i].end_hole = 31
    else
        U move_amount = randb(16 - cliff_hole)

        if cliff_midpoint < 16
            cliff_midpoint += move_amount
        else
            cliff_midpoint -= move_amount

        if rand() & %111 == 0
            cliffs[i].begin_hole = cliff_midpoint - cliff_hole
            cliffs[i].end_hole   = cliff_midpoint + cliff_hole
        else if cliff_index & %10000
            cliffs[i].begin_hole = cliff_midpoint - cliff_hole
            cliffs[i].end_hole   = 31
        else
            cliffs[i].begin_hole = 1
            cliffs[i].end_hole   = cliff_midpoint + cliff_hole

        

ct fn cliff_ppuaddr_table() UU[SCROLL_HEIGHT]
    UU[60] ret
    for U i = 0; i < 30; i += 1
        ret[i] = $2000 + (UU(i) << 5)
    for U i = 0; i < 30; i += 1
        ret[i+30] = $2800 + (UU(i) << 5)
    return ret

fn ppu_upload_cliff()
    {PPUSTATUS}()
    {PPUADDR}(cliff_ppuaddr_table()[cliff_y].b)
    {PPUADDR}(cliff_ppuaddr_table()[cliff_y].a)

    Cliff cliff = cliffs[(cliff_index & %11111) >> 1]
    U i = 0

    for ; i < cliff.begin_hole; i += 1
        {PPUDATA}($01)
    for ; i < cliff.end_hole; i += 1
        {PPUDATA}($00)
    for ; i < 32; i += 1
        {PPUDATA}($01)

