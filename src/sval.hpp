#ifndef CVAL_HPP
#define CVAL_HPP

#include <iostream> // TODO
#include <functional>
#include <memory>
#include <variant>
#include <vector>

#include <boost/container/small_vector.hpp>

#include "robin/map.hpp"

#include "decl.hpp"
#include "type.hpp"
#include "ir_edge.hpp"

namespace bc = boost::container;

using ct_array_t = std::shared_ptr<ssa_value_t[]>;
using ct_variant_t = std::variant<ssa_value_t, ct_array_t>;

inline ct_array_t make_ct_array(unsigned size)
{
    // TODO: Change this to 'make_shared' when std library updates to c++20.
    auto array = ct_array_t(new ssa_value_t[size]());
    for(unsigned i = 0; i < size; ++i)
        std::cout << "ct array = " << array[i] << std::endl;
    return array;
}

inline ssa_value_t const* ct_array(ct_variant_t const& variant)
{
    if(ct_array_t const* array = std::get_if<ct_array_t>(&variant))
        return array->get();
    return nullptr;
}

// Struct value
using sval_t = bc::small_vector<ct_variant_t, 1>;

// Creates a sval from a single ssa value
inline sval_t make_sval(ssa_value_t v) { return { v }; }
//sval_t make_sval(type_t type);
//sval_t make_sval(type_t type, std::function<ssa_value_t(type_t)> const& gen);

bool is_ct(sval_t const& sval);

struct spair_t
{
    sval_t value;
    type_t type;
};

struct ct_pair_t
{
    ct_array_t array;
    type_t type;

    bool operator==(ct_pair_t const& o) const { return array == o.array && type == o.type; }
    bool operator!=(ct_pair_t const& o) const { return !operator==(o); }
};

template<>
struct std::hash<ct_pair_t>
{
    std::size_t operator()(ct_pair_t const& pair) const noexcept
    {
        std::size_t h = std::hash<ct_array_t>{}(pair.array);
        return rh::hash_combine(h, pair.type.hash());
    }
};

/*
class ct_manager_t
{
public:
    class locator_t insert(fn_ht fn, ct_pair_t const& pair);

    void clear() 
    { 
        m_ct_pair_map.clear();
        m_ct_pairs.clear();
    }
private:
    // Compile-time arrays may be generated by 'eval_t'.
    // These get stored here:
    rh::robin_map<ct_pair_t, unsigned> m_ct_pair_map;
    std::vector<ct_pair_t> m_ct_pairs;
};
*/

/* TODO remove
template<>
struct std::hash<spair_t>
{
    std::size_t operator()(spair_t const& s) const noexcept
    {
        std::size_t h = std::hash<type_t>{}(s.type);
        for(auto const& v : s.value)
            h = rh::hash_combine(h, v.target());
        return h;
    }
};
*/

// TODO: remove
//spair_t const* new_spair(cpair_t const& cpair);
//cpair_t const* new_cpair(cpair_t&& cpair);

#endif
