#ifndef STMT_HPP
#define STMT_HPP

#include <mutex>
#include <string>
#include <vector>
#include <type_traits>
#include <limits>

#include <boost/container/small_vector.hpp>

#include "array_pool.hpp"
#include "ir_decl.hpp"
#include "handle.hpp"
#include "parser_decl.hpp"
#include "pstring.hpp"
#include "mods.hpp"

// stmts form a crude IR that is generated by the parser and 
// sent to the SSA IR builder.

namespace bc = ::boost::container;

struct stmt_ht : handle_t<stmt_ht, std::uint32_t, ~0> {};
struct stmt_mods_ht : handle_t<stmt_mods_ht, std::uint16_t, ~0> {};

#define STMT_XENUM \
    X(STMT_END_FN,     0)\
    X(STMT_IF,         true)\
    X(STMT_ELSE,       0)\
    X(STMT_END_IF,     0)\
    X(STMT_END_DO,     true)\
    X(STMT_WHILE,      true)\
    X(STMT_END_WHILE,  0)\
    X(STMT_FOR,        true)\
    X(STMT_FOR_EFFECT, true)\
    X(STMT_END_FOR,    0)\
    X(STMT_EXPR,       true)\
    X(STMT_DO,         0)\
    X(STMT_RETURN,     true)\
    X(STMT_BREAK,      0)\
    X(STMT_CONTINUE,   0)\
    X(STMT_LABEL,      0)\
    X(STMT_GOTO,       0) \
    X(STMT_GOTO_MODE,  true)

// Negative values represent var inits, where the negated value 
// holds the bitwise negated index of the fn variable.
// (See 'get_local_var_i')
enum stmt_name_t : std::int16_t
{
    STMT_MIN_VAR_DECL = std::numeric_limits<std::int16_t>::min(),
    STMT_MAX_VAR_DECL = -1,
#define X(x, e) x,
    STMT_XENUM
#undef X
};

bool has_expression(stmt_name_t stmt);

std::string to_string(stmt_name_t);

constexpr bool is_var_init(stmt_name_t stmt_name)
{
    return std::underlying_type_t<stmt_name_t>(stmt_name) < 0;
}

constexpr unsigned get_local_var_i(stmt_name_t stmt_name)
{
    assert(is_var_init(stmt_name));
    return ~static_cast<unsigned>(stmt_name);
}

struct stmt_t
{
    stmt_name_t name;
    stmt_mods_ht mods;
    stmt_ht link; // A stmt index, used to speed-up interpreters
    pstring_t pstring;
    union
    {
        token_t const* expr;
        unsigned use_count; // Used for labels
    };
};

std::string to_string(stmt_name_t stmt_name);

// Represents function data right after parsing
class fn_def_t
{
public:
    unsigned num_params = 0;
    src_type_t return_type;
    // First elems are params
    std::vector<var_decl_t> local_vars;
    std::vector<stmt_t> stmts;
    std::vector<mods_t> mods;

    stmt_t const& operator[](stmt_ht h) const { return stmts[h.id]; }
    stmt_t& operator[](stmt_ht h) { return stmts[h.id]; }

    mods_t const& operator[](stmt_mods_ht h) const { return mods[h.id]; }
    mods_t& operator[](stmt_mods_ht h) { return mods[h.id]; }

    stmt_ht next_stmt() const { return { stmts.size() }; }

    stmt_ht push_stmt(stmt_t stmt) 
    { 
        stmt_ht const handle = next_stmt();
        stmts.push_back(stmt); 
        return handle;
    }

    stmt_ht push_var_init(unsigned name, token_t const* expr, pstring_t pstring)
    { 
        return push_stmt({ static_cast<stmt_name_t>(~name), {}, {}, pstring, expr }); 
    }

    stmt_mods_ht push_mods(mods_t&& m)
    {
        if(!m)
            return {};
        stmt_mods_ht const handle = { mods.size() };
        mods.push_back(std::move(m));
        return handle;
    }

    // Returns the first pstring matching 'global'.
    // Intended to be used for error messages.
    pstring_t find_global(global_t const* global) const;
};

#endif
