#ifndef STMT_HPP
#define STMT_HPP

#include <mutex>
#include <string>
#include <vector>

#include <boost/container/small_vector.hpp>

#include "array_pool.hpp"
#include "ir_decl.hpp"
#include "handle.hpp"
#include "parser_decl.hpp"
#include "pstring.hpp"

// stmts form a crude IR that is generated by the parser and 
// sent to the SSA IR builder.

namespace bc = ::boost::container;

using stmt_ht = handle_t<unsigned, struct stmt_ht_tag, ~0>;

#define STMT_XENUM \
    X(STMT_END_FN,     0)\
    X(STMT_IF,         true)\
    X(STMT_ELSE,       0)\
    X(STMT_END_BLOCK,  0)\
    X(STMT_END_DO,     true)\
    X(STMT_WHILE,      true)\
    X(STMT_END_WHILE,  0)\
    X(STMT_FOR,        true)\
    X(STMT_FOR_EFFECT, true)\
    X(STMT_END_FOR,    0)\
    X(STMT_EXPR,       true)\
    X(STMT_DO,         0)\
    X(STMT_RETURN,     true)\
    X(STMT_BREAK,      0)\
    X(STMT_CONTINUE,   0)\
    X(STMT_LABEL,      0)\
    X(STMT_GOTO,       0) \
    X(STMT_GOTO_MODE,  true)

// Negative values represent var inits, where the negated value 
// holds the bitwise negated index of the fn variable.
// (See 'get_local_var_i')
enum stmt_name_t : int
{
    STMT_MIN_VAR_DECL = INT_MIN,
    STMT_MAX_VAR_DECL = -1,
#define X(x, e) x,
    STMT_XENUM
#undef X
};

bool has_expression(stmt_name_t stmt);

std::string to_string(stmt_name_t);

constexpr bool is_var_init(stmt_name_t stmt_name)
{
    return stmt_name < STMT_END_BLOCK;
}

constexpr unsigned get_local_var_i(stmt_name_t stmt_name)
{
    assert(is_var_init(stmt_name));
    return ~static_cast<unsigned>(stmt_name);
}

struct stmt_t
{
    stmt_name_t name;
    stmt_ht link; // A stmt index, used to speed-up interpreters
    pstring_t pstring;
    union
    {
        token_t const* expr;
        unsigned use_count; // Used for labels
    };
};

std::string to_string(stmt_name_t stmt_name);

// Represents function data right after parsing
class fn_def_t
{
public:
    unsigned num_params = 0;
    src_type_t return_type;
    // First elems are params
    std::vector<var_decl_t> local_vars;
    std::vector<stmt_t> stmts;

    stmt_t const& operator[](stmt_ht h) const { return stmts[h.value]; }
    stmt_t& operator[](stmt_ht h) { return stmts[h.value]; }

    stmt_ht next_stmt() const { return { stmts.size() }; }

    stmt_ht push_stmt(stmt_t stmt) 
    { 
        stmt_ht handle = next_stmt();
        stmts.push_back(stmt); 
        return handle;
    }

    stmt_ht push_var_init(unsigned name, token_t const* expr)
    { 
        stmt_ht handle = next_stmt();
        stmts.push_back({ static_cast<stmt_name_t>(~name), {}, {}, expr }); 
        return handle;
    }
};

#endif
