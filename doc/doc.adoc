= NESFab
Copyright (c) 2022, Pubby
Version TODO
:sectnums:
:toc2:
:toclevels: 3
:toc-title: Table of Contents
                                                                    
:description: Example AsciiDoc document                             
:keywords: AsciiDoc
:imagesdir: ./img

This is the optional preamble (an untitled section body). Useful for
writing simple sectionless documents consisting only of a preamble.
AsciiDoc is kool

== What is NESFab?

NESFab is a statically-typed, procedural programming language for creating NES games. 
Designed with 8-bit limitations in mind, the language is more ergonomic to use than C, while also producing faster assembly code. 
It's easy to get started with, and has a useful set of libraries for making your first -- or hundredth -- NES game.

=== Limitations

- NESFab supports a limited number of cartridge mappers. 
  Some mappers, like Nintendo's MMC5, will likely never be supported.
- Although assembly language can be mixed with NESFab code,
  there are restrictions and inefficiencies by doing so.

  TODO

=== Mappers

=== NESFab vs Assembly

Assembly Pros

- Smaller, more consistent
- Smaller

Assembly languages get a bad rap these days, 
but it's important to understand that not all assembly lanaguages are the same.
The NES's 6502 processor hails from the 1970s, 
back when assembly languages were designed to be written by humans, not compilers.
It has a simple instruction set with only 3 registers, 
and that keeps the code readable and sprinkled with identifiers.

For many simple NES games, assembly language is an excellent choice,
but as the games get bigger and more complicated, warts in 6502 assembly language do begin to appear:

- It's not viable to store data on the hardware stack, 
  meaning all variables must be declared as globals.
  Due to the small amount of RAM, this leads to variables
  being reused for different purposes, which is a very error-prone way to code.
  With complicated call graphs, it's a total mess!
- The NES is an 8-bit system, but many games desire 16, 24, or 32 bits of precision for math,
  and this requires chaining together multiple 8-bit operations.
  If you have to do this for an entire program, it gets exhausting.
  Macros help somewhat, but generate poor code on a system that demands efficiency.
- Larger programs require the use of *banks* to extend the program's address space.
  These have to be defined by hand, with the programmer carefully laying out
  what snippets of code goes where. If you happen to change your mind later on,
  see you in several hours as it's it's a chore to relocate large swathes of code from bank to bank.

NESFab was created to solve these three problems:

- The compiler analyzes functions and efficiently allocates local variables for you.
- The compiler produces efficient code for high-precision math, with no extra verbosity on the programming side.
- Banks are abstracted away. One need not worry about what code goes where.

TODO: remove?

=== NESFab vs C

C is sometimes referred to as a portable assembly language, 
with the belief that C closely describes how the underlying hardware works.
This wasn't really true in the past, 
as old architectures like the NES's 6502 don't map cleanly to C's features.
It's also not so true in the present, 
as modern CPUs are abstracted to mimic C's interface, not the other way around.
But the phrase still gets tossed around.

Regarding the 6502's compatability with C, a few issues arrise:

- C defines `int` as 16-bits and promotes most math, but the NES's 6502 is an 8-bit system where 16-bit math is slow.
- C demands fast addressing modes for array access, with arrays stored contigious in memory. 
  The 6502 struggles with both of these.
- C has no concept of banks. Writing multi-bank programs in C requires complicated linker scripts,
  and is often more difficult than doing so in assembly.

Pros
- 
- NESFab comes "batteries included", 
  with support for importing all sorts of different game data formats.

Cons

- There is only one NESFab compiler, but multiple C compilers.
- C is more portable. This is less significant for writing NES games than say, writing modern apps.

TODO


- Useful behavior is undefined or unspecified. 
  You can't overflow signed values for example, and interfacing with hardware is non-obvious and error-prone.


=== NESFab for Language Nerds

TODO

This tutorial assumes you know the basics of computer programming.
If you are new to the field, you'll likely want to learn another language -- like Python or C -- first.
Do not worry about wasted effort, as even if you're writing NES games, 
it can be helpful to write tools and conversion scripts in other languages.

== Surprises

=== Operators

- The operators `&`, `|`, and `^` have a <<binop, higher precedence>> than in C.
- Combined-assignment operators, like `+=` or `<<=`, return a `Bool`: the carry.

=== Pointers

- Most values cannot be referenced via pointers.


== Getting Started

=== Installation

To get started with NESFab, download it from TODO and extract it. 
You will also want a NES emulator with debugging features, like 
https://fceux.com/[FCEUX], https://www.mesen.ca/[Mesen], or https://www.qmtpro.com/~nes/nintendulator/[Nintendulator].

TODO: more installation

TODO: syntax highlighting

=== Compiling your first ROM [[firstrom]]

The `nesfab` tool compiles `.fab` source code files into `.nes` ROMs. 
It can be used with the command-line, or by clicking and dragging a file onto the executable.

To compile your first ROM, create a file called `hello.fab` and save it with code below:

----
// TODO: hello world
----

If using the command-line, you can compile it using the command:

`nesfab hello.fab`

Otherwise, drag the `hello.fab` file onto the `nesfab` executable.

When done, the compiler should have produced an `a.nes` file in the same directory,
which is the default name of compiled binaries. 
Try running `a.nes` in your NES emulator.
You should see the screen flash with colors TODO.

=== Your first configuration file

The `nesfab` compiler accepts options both on the command-line, and via configuration files.
For most projects, a single configuration file is ideal, so this section will focus on that.

Below is an example configuration file: `config.cfg`: 
----
output = "game.nes"
input = "hello.fab"
----
The `output` option determines the name of the `.nes` file, while `input` lists a single source file.

To compile using this configuration file, either run:

`nesfab config.cfg`

Or drag the `config.cfg` file onto the `nesfab` executable.

It should produce the same result as <<firstrom, before>>, but the ROM will be saved as `game.nes` instead of `a.nes`
because the `output` option was set.

For more details about configuration files, see the reference page. TODO

----
# This is a comment

# Cause all warnings to become errors:
error-on-warning = true

# Set the output file name:
output = "game.nes"

# To use multiple source code files, use multiple input options:
input = "hello.fab"
input = "another_file.fab"
input = "a_third_file.fab"
----

=== Beginner roadmap

TODO!

== Configuration Options

=== `help` (`-h`)

Prints a list of command-line options.

This option is only available via the command-line.

*Command-line usage:*
----
nesfab --help
----

=== `version` (`-v`)

Prints information about the NESFab executable, including its version history.

This option is only available via the command-line.

*Command-line usage:*
----
nesfab --version
----

=== `input` (`-i`)

Specifies a file to be compiled, which can either be a source file with extension `.fab`, 
or a configuration file with extension `.cfg`.
This option can be used multiple times to compile multiple files.

Note: the flags `--input` and `-i` are optional when using the command line,
as any argument not belonging to another option will be interpreted as an `input`.

*Command-line usage:*
----
nesfab --input "file1.fab" --input "file2.fab" --input "another_config.cfg"
----

or:

----
nesfab "file1.fab" "file2.fab" "another_config.cfg"
----

*Configuration file usage:*
----
input = "file1.fab"
input = "util/file2.fab"
input = "another_config.cfg"
----

=== `output` (`-o`)

Specifies the name of the executable `.nes` file the compiler will produce.
This option can only be specified once.

By default, the value is `"a.nes"`.

*Command-line usage:*
----
nesfab --output "game.nes"
----

*Configuration file usage:*
----
output = "game.nes"
----

=== `code-dir` (`-I`) [[codedir]]

Specifies a directory to be searched when compiling source code files.
This option can be used multiple times to specify multiple directories.

Commonly, this option is used when several source files exist in the same directory.
`code-dir` can specify this directory, then `input` can specify the files inside it
without having to reference the directory name.

*Command-line usage:*
----
nesfab --code-dir "some_directory/"
----

*Configuration file usage:*
----
code-dir = "some_directory/"
----

=== `resource-dir` (`-R`)

Specifies a directory to be searched when importing data files.
This option can be used multiple times to specify multiple directories.

This behaves like <<codedir,`code-dir`>>, but applies to the files imported by the `file` keyword. TODO: write about file

*Command-line usage:*
----
nesfab --resource-dir "some_directory/"
----

*Configuration file usage:*
----
resource-dir = "some_directory/"
----

=== `mapper` (`-M`) [[mapperopt]]

Specifies the mapper used. The argument is a <<mappers,mapper name>>.
This option can only be specified once.

By default, the value is `nrom`.

*Command-line usage:*
----
nesfab --mapper bnrom
----

*Configuration file usage:*
----
mapper = bnrom
----

=== `mirroring` (`-m`) [[mirroringopt]]

Specifies the mirroring used for <<mappers,mappers with fixed mirrorings>>.
This option can only be specified once.

This option expects one argument. Any of the following arguments are valid:

|===
|Argument |Description

| V
| Vertical Mirroring

| H
| Horizontal Mirroring

| 4
| 4-Way Mirroring

|===

If the mapper supports multiple mirrorings, the default value is `V`.

*Command-line usage:*
----
nesfab --mirroring H
----

*Configuration file usage:*
----
mirroring = H
----

=== `prg-size` (`-p`) [[prgopt]]

Specifies the size of PRG (the amount of memory for code) in increments of 1 KiB.
This option can only be specified once.

The default value depends on the mapper. 
These values correspond with common cartridge designs.

|===
|Name (HTML link) |Default Value

| https://www.nesdev.org/wiki/NROM[`nrom`]
| 32

| https://www.nesdev.org/wiki/AxROM[`anrom`]
| 256

| https://www.nesdev.org/wiki/BNROM[`bnrom`]
| 128

| https://www.nesdev.org/wiki/CNROM[`cnrom`]
| 32

| https://www.nesdev.org/wiki/GxROM[`gnrom`]
| 128

| https://www.nesdev.org/wiki/GTROM[`gtrom`]
| 512

|===

[NOTE]
Just because the compiler accepts a `prg-size` does not mean that corresponding hardware exists in the real world.
Only the default size is asserted to be commonly available.

*Command-line usage:*
----
nesfab --prg-size 128
----

*Configuration file usage:*
----
prg-size = 128
----

=== `chr-size` (`-c`) [[chropt]]

Specifies the size of CHR (the amount of memory for tilesets) in increments of 1 KiB.
This option can only be specified once.

The default value depends on the mapper. 
These values correspond with common cartridge designs.

|===
|Name (HTML link) |Default Value

| https://www.nesdev.org/wiki/NROM[`nrom`]
| 8

| https://www.nesdev.org/wiki/AxROM[`anrom`]
| 8

| https://www.nesdev.org/wiki/BNROM[`bnrom`]
| 8

| https://www.nesdev.org/wiki/CNROM[`cnrom`]
| 32

| https://www.nesdev.org/wiki/GxROM[`gnrom`]
| 32

| https://www.nesdev.org/wiki/GTROM[`gtrom`]
| 2

|===

[NOTE]
Just because the compiler accepts a `chr-size` does not mean that corresponding hardware exists in the real world.
Only the default size is asserted to be commonly available.

*Command-line usage:*
----
nesfab --chr-size 32
----

*Configuration file usage:*
----
chr-size = 32
----

=== `threads` (`-j`)

Specifies how many threads the compiler can use, enabling parallel compilation.
This option expects an integer argument, and can only be specified once.

By default, the value is 1.

In general, a value slightly above the number of CPU cores available is ideal.
Performance may degrade if the number is too high.

*Command-line usage:*
----
nesfab --threads 4
----

*Configuration file usage:*
----
threads = 4
----

=== `error-on-warning` (`-W`)

This option turns warnings into errors and halts compilation whenever a warning occurs.
This option expects no arguments and can only be specified once.

*Command-line usage:*
----
nesfab --error-on-warning
----

*Configuration file usage:*
----
error-on-warning = 1
----


== Supported Mappers [[mappers]]

NESFab supports a small set of https://www.nesdev.org/wiki/Mapper[mappers],
which determine the capabilities of a cartridge.
The choice of mapper determines the amount of space available for code, the https://www.nesdev.org/wiki/Mirroring[nametable mirroring], and https://www.nesdev.org/wiki/CHR_ROM_vs._CHR_RAM[whether CHR data is stored in RAM or ROM].

*For beginners:* It is recommended to start with `nrom` (the default), 
and only consider switching once your program grows too large for it.

[NOTE]
The mapper names in the table below are links.

|===
|Name |Max PRG (Code) |Max CHR (Tilesets) | Nametable VRAM |Mirroring

| https://www.nesdev.org/wiki/NROM[`nrom`]
| 32 KiB
| 8 KiB
| 2 KiB
| Fixed H or V

| https://www.nesdev.org/wiki/AxROM[`anrom`]
| 512 KiB
| 8 KiB (RAM)
| 2 KiB
| Switchable H or V

| https://www.nesdev.org/wiki/BNROM[`bnrom`]
| 8192 KiB
| 8 KiB (RAM)
| 2 KiB
| Fixed H or V

| https://www.nesdev.org/wiki/CNROM[`cnrom`]
| 32 KiB
| 2048 KiB
| 2 KiB
| Fixed H or V

| https://www.nesdev.org/wiki/GxROM[`gnrom`]
| 512 KiB
| 128 KiB
| 2 KiB
| Fixed H or V

| https://www.nesdev.org/wiki/GTROM[`gtrom`]
| 512 KiB
| 16 KiB (RAM)
| 8 KiB
| Fixed 4

|===

For information on how to configure NESFab for a specific mapper, see:

- <<mapperopt>>
- <<mirroringopt>>
- <<prgopt>>
- <<chropt>>

== Basic Concepts

=== Value Semantics

== Keywords

=== `if`

The `if` <<statement, statement>> allows for conditional execution of <<blocks, code blocks>>.
It behaves like `if` in most programming languages.

Syntax:
----
if expression
    code block
----

The conditional expression of `if` will be converted to `Bool`.
If this evaluates to `true`, the body of the `if` statement will be executed.

=== `else`

The `else` <<statement, statement>> allows for control flow to branch between two <<blocks, code blocks>>.
It behaves like `else` in most programming languages.

This statement must be paired with a corresponding `if.`

Syntax:
----
if expression
    code block
else
    code block
----

If the corresponding `if` evaluates to `false`, the body of the `else` statement will be executed.

For visual appeal, other statements may follow the `else` keyword on the same line, including `if`, `for`, and `while`.
This looks like:

----
if expression
    code block
else if expresssion
    code block
else
    code block
----

=== `while` [[kw_while]]

The `while` <<statement, statement>> allows for looping control flow.
It behaves like `while` in most programming languages.

Syntax:
----
while condition
    code block
----

`condition` is an expression converted to `Bool`. While this expression evaluates to `true`, the loop body will execute.
After the code in `code block` executes, control flow jumps back to the `condition` test.

=== `for` [[kw_for]]

The `for` <<statement, statement>> allows for looping control flow, with more features than <<kw_while>>.
It behaves like `for` in most programming languages.

Syntax:
----
for initialization ; condition ; iteration
    code block
----

- `initialization` executes before the loop and can be an expression or a variable initialization.
- `condition` is an expression converted to `Bool`. While this expression evaluates to `true`, the loop body will execute.
- `iteration` is an expression to be run at the end of every iteration (following the code block).

Any of these expressions may be empty. An empty `condition` is equivalent to `true`.

After the code in `code block` executes, `iteration` executes, and then control flow jumps back to the `condition` test.

Like `while`, the keywords <<kw_break>> and <<kw_continue>> may be used inside of a `for`.

For visual appeal, the expressions of `for` may be put on separate lines starting with the `;` character, like so:

----
for initialization
; condition
; iteration
    code block
----

=== `do` [[kw_do]]

The `do` keyword can be prefixed to either <<kw_while>> or <<kw_for>> to alter their behavior.
A loop with `do` skips the `condition` check of its first iteration.

Syntax:
----
do while condition
    code block

do for initialization ; condition ; iteration
    code block
----

[NOTE]
Loops written with `do` often have better runtime performance than loops written without.

=== `break` [[kw_break]]

`break` ends the execution of the containing <<kw_while>>, <<kw_for>>, or <<kw_switch>> statement.
It behaves like `break` in most programming languages.

Syntax:
----
break
----

Example:
----
for U i = 0; i < 10; i += 1
    if array[i] == 0
        break // Exits the loop
----

If you want to exit out of multiple nested statements, use <<kw_goto>>.

=== `continue`

`continue` is used inside <<kw_while>> or <<kw_for>> statements,
and causes control flow to jump to the end of the loop's code block.
It behaves like `condition` in most programming languages.

Syntax:
----
continue
----

Example:
----
for U i = 0; i < 10; i += 1
    if array[i] == 0
        continue // If this executes, the line below it won't.
    array[i] += i
----

=== `switch` [[kw_switch]]

The `switch` statement branches control flow based on an byte value.
`switch` is similar to <<kw_if>>, but instead of having a choice between two code blocks, 
`switch` allows multiple. It behaves like `switch` in most programming languages.

Syntax:
----
switch expression
    code block
----

`expression` must be of type `U` or `S`.

`switch` is intended to be used with <<kw_case>> and <<kw_default>>.
Both of these label where control flow will jump.

Example:
----
switch player_state
    case 0
        do_run()
        break

    case 1
        do_jump()
        break

    case 2
        do_kick()
        break

    default:
        do_nothing()
        break
----

=== `case` [[kw_case]]

`case` is used inside of <<kw_switch>> statements as a label.
Control flow will jump to the `case` from the `switch` if the switch's expression matches the `case` value.

Syntax:
----
case constant expression
    code block
----

`constant expression` is an expression which can be computed at compile-time.

The `code block` of `case` exists only to provide a scope.
There is no other difference between the syntax above, and this:

----
case constant expression
code block
----

As stated, `case` is a label.
It can appear inside other statements such as <<kw_for>> or <<kw_if>>.

See more examples in <<kw_switch>>.

=== `default` [[kw_default]]

`default` is used inside of <<kw_switch>> statements as a label.
Control flow will jump to the `default` from the `switch` if the switch's expression matches no enclosed <<hw_case>> statemen.

Syntax:
----
default
    code block
----

The `code block` of `default` exists only to provide a scope.
There is no other difference between the syntax above, and this:

----
default
code block
----

As stated, `default` is a label.
It can appear inside other statements such as <<kw_for>> or <<kw_if>>.

See more examples in <<kw_switch>>.

=== `goto` [[kw_goto]]

The keyword `goto` has use in two different types of statements: `goto` and `goto mode`.

==== `goto` statement [[kw_goto_statement]]

The `goto` statement causes control flow to jump to a corresponding <<kw_label>> in the same function.
It behaves like `goto` in most programming languages.

Syntax:
----
goto identifier
----

`identifier` refers to the name of a label in the current function.

Example:

----
fn example()
    U i = 0
    label loop
    i += 1
    if i < 10
        goto loop
----

==== `goto mode` statement [[kw_goto_mode_statement]]

The `goto mode` statement causes control flow to jump to a <<TODO_mode>>, 
discarding the current call stack and starting anew.
In the process, global variables will be reset to their initial value,
unless they are explicitly preserved using <<kw_preserves>> in the `goto mode` statement.

Syntax:
----
goto mode identifier(arguments)
: preserves /groups
----

- `identifier` if the name of a <<TODO_mode>> function.
- `arguments` is a comma-separated list of expressions to be passed to the `mode` function. The list may be blank.
- `groups` are a comma-separated list of <<kw_vars>> groups, denoting which variables should not be reset. The list may be blank.

Note that `preserves` is a required <<modifier, modifier>> of this statement.

Example:

----
vars /my_vars
    U some_var = 10

mode foo()
    goto mode bar(some_var + 1)
    : preserves

mode bar(U some_argument)
    my_vars = some_argument

    goto mode foo()
    : preserves /my_vars
----

==== `goto` (assembly) [[kw_goto_asm]]

TODO

==== `goto mode` (assembly) [[kw_goto_mode_asm]]

TODO

=== `label` [[kw_label]]

The `label` statement introduces a point which a <<kw_goto_statement>> can jump to . 
It has no effect otherwise.
It behaves like labels in most programming languages, albeit with a slightly different syntax.

Syntax:
----
label identifier
    code block
----

The `code block` of `label` exists only to provide a scope.
There is no other difference between the syntax above, and this:

----
label identifier
code block
----

=== `return` [[kw_return]]

==== `return` statement [[kw_return_statement]]

The `return` statement ends the execution of the current function,
using its argument as the function's return value.
It behaves like `return` in most programming languages.

Syntax:
----
return expression
----

Syntax for functions lacking a return value:
----
return
----

==== `return` expression [[kw_return_expression]]

A `return` expression *does not cause functions to return*. 
Instead, it provides a handle to the current function's return value.
Although the value itself cannot be used, the address of can be taken using <<unary_ops, unary operator>> `&`,

This functionality exists because of <<TODO, inline assembly>>.
Most often, it is used to allow inline assembly functions to return values
by storing into the address.

Example:
----
AA return_addr = &return
----

=== `fence` [[kw_fence]]

The `fence` statement is used for both writing concurrent code, and for interacting with hardware. 
It imposes constraints on how global variables are loaded and stored,
preventing the compiler from re-ordering them.

More precisely:

- Every global variable the function is tracking will be stored before the `fence` executes.
- Every global variable the function is tracking will be loaded after the `fence` executes.

*Why is `fence` a thing?*

The NESFab compiler performs optimizations which moves loads and stores around.
This is normally fine, but issues arise due to interrupts.

To illustrate, take a look at the code below:
----
foo = 10
bar = 20
----
The compile is free to re-order these global variable assignments, storing into `bar` before `foo`.
However, imagine if an interrupt were to occur between these stores.
The interrupt would see that `bar` equals `20`, but not `foo` equals `10`,
as the store to `foo` hasn't happened yet.

To prevent this re-ordering, a `fence` statement can be used:
----
foo = 10
fence
bar = 20
----
Now if the interurpt sees that `bar` equals `20`, `foo` must equal `10`.

*Another purpose for `fence`:*

`fence` is also used when interacting with the hardware directly.
When reading or writing a global variable via its hardware address,
two `fence` statements are required with the hardware access between them.
These `fence` statements instruct the compiler to store the global before the hardware access,
and load the value after it.

A common example arises when doing https://www.nesdev.org/wiki/PPU_registers#OAMDMA[OAM DMA]:
----
fence
{OAMDMA}((&oam).b)
fence
----

Without these `fence` instructions, the compiler would not recognize that global variables are being read.
and so the resulting read may have incorrect results.

[NOTE]
`fence` does not instruct the compiler *which* globals to track.
To do that, the modifier <<hw_employs>> is required.

=== `true` [[kw_true]]

`true` is an expression of type `Bool`, and has a compile-time constant value.
When converted to an integer type, it will have the value `1`.

Syntax:
----
true
----

=== `false` [[kw_false]]

`false` is an expression of type `Bool`, and has a compile-time constant value.
When converted to an integer type, it will have the value `0`.

Syntax:
----
false
----

=== `ready` [[kw_ready]]

`ready` is an expression of type `Bool` which returns `true` if both an <<nmi, NMI>> is active and the program was <<kw_nmi, waiting on one>>,
or `false` otherwise. 
It is intended to be used as a synchronization primitive (https://en.wikipedia.org/wiki/Lock_(computer_science[mutex])
to avoid https://en.wikipedia.org/wiki/Race_condition[race conditions] inside of NMI handlers.

Syntax:
----
ready
----

In general, if `ready` is `true`, all global variables are in a stable, concurrent-safe state.
Likewise, if `ready` is `false`, either no NMI is happening, or the program is lagging one or more frames.

Example:
----
nmi foo()
    if ready
        upload_data()
        poll_controller()
    play_music()
----

The address of `ready` can be taken using <<unary_ops, unary operator>> `&`,
but the pointed-to value must never be modified by the program.

[NOTE]
There is more than one way to achieve concurrent safety. See <<kw_fence>>, for example.

=== `fn` [[kw_fn]]

The `fn` keyword declares a 
https://en.wikipedia.org/wiki/Function_(computer_programming)[function]
at global scope.

Syntax:
----
fn identifier(parameters) ReturnType
    code block
----

- `identifier` is the name of the function.
- `parameters` is a comma-separated list of variables with the syntax `Type name`.
- `ReturnType` is a type name, but is optional. Leaving `ReturnType` blank is the same as specifying it as `Void`.
- `code block` is the block of code which implements the function.

Functions can only be declared at global-scope.
Unlike other programming languages, functions in NESFab cannot be nested or recursive.

*Modifiers:*

- `employs`: A list of groups. See <<kw_employs_mod>>.
- `vars`: A list of `vars` groups. See <<kw_vars_mod>>.
- `data`: A list of `data` groups. See <<kw_data_mod>>.
- `+zero_page`, `-zero_page`: Allocate local variables using fast zero-page RAM.
- `+inline`, `-inline`: Force / prevent the function from being inlined.

Example:
----
fn foo(U p1, U p2) U
    return p1 + p2
----

TODO: inline assembly

=== `ct` [[kw_ct]]

`ct` is short for _compile-time_. 
The keyword can be prefixed onto value and function declarations to *insist* that their computations occur compile-time.

==== `ct fn`

Syntax:
----
ct fn identifier(parameters) ReturnType
----

`ct fn` has the same syntax as <<kw_fn>>. 

==== `ct` value

Syntax:
----
ct TypeName identifier = value
----

`ct` values are declared with the syntax of regular variables, but must be defined a value.

They can be declared at global scope, or inside functions.

=== `mode`

The `mode` keyword declares a mode function at global scope. 
Modes are similar to <<kw_fn, regular functions>>, but they do not return.
Instead, the only way to leave a mode function is via a `<<kw_goto_mode_statement>>.

Syntax:
----
mode identifier(parameters)
    code block
----

- `identifier` is the name of the mode function.
- `parameters` is a comma-separated list of variables with the syntax `Type name`.
- `code block` is the block of code which implements the mode function.

Every program is required to have a mode named `main` defined, which takes no parameters.
When the program starts, execution will begin at `main`.
This behavior is similar to `main` functions found in other programming languages.

Modes can be assigned a corresponding <<kw_nmi_decl, nmi>> function, using a <<TODO, modifier>>.
While the mode function is executing, NMIs will be handled using the supplied `nmi` function.

*Modifiers:*

- `nmi`: The name of the `nmi` function to use when executing this `mode`.
- `employs`: A list of groups. See <<kw_employs_mod>>.
- `vars`: A list of `vars` groups. See <<kw_vars_mod>>.
- `data`: A list of `data` groups. See <<kw_data_mod>>.
- `+zero_page`, `-zero_page`: Allocate local variables using fast zero-page RAM.

Example:
----
mode main()
: nmi my_nmi
    while true
        x = x + 1
----

*Why do modes exist?*

There are two reasons.

First, it is convenient to be able to change what the program is doing deep inside a function call.
For example, in a video game it can be useful to define one `mode` for the main menu, 
and another one for the actual gameplay. 
To switch between the two, a `goto mode` statement can be used anywhere in the program,
which is nicer than having to use variables and switch-cases.

But more importantly, modes allow the compiler to smartly allocate memory,
enabling variables used in different modes to share RAM addresses.
This happens transparently from the programmer; no https://en.wikipedia.org/wiki/Tagged_union[sum types] needed.

=== `nmi`

The keyword `nmi` can be used as a statement, or as a declaration.

==== `nmi` statement

The `nmi` statement blocks execution until an <<kw_nmi_function>> occurs.
Until the `nmi` statement returns, <<kw_ready>> will evaluate to <<kw_true>>.

Syntax:
----
nmi
----

==== `nmi` function [[kw_nmi_function]]

The `nmi` keyword declares an https://www.nesdev.org/wiki/NMI[NMI] interrupt function at global scope. 
NMI interrupts are similar to <<kw_fn, regular functions>>, but they have no parameters, cannot return, and cannot be called.
Instead, they execute once per frame at the start of https://en.wikipedia.org/wiki/Vertical_blanking_interval[VBLANK],
so long as bit 7 of https://www.nesdev.org/wiki/PPU_registers#PPUCTRL[PPUCTRL] is set.

Syntax:
----
nmi identifier()
    code block
----

- `identifier` is the name of the mode function.
- `code block` is the block of code which implements the mode function.

*Modifiers:*

- `employs`: A list of groups. See <<kw_employs_mod>>.
- `vars`: A list of `vars` groups. See <<kw_vars_mod>>.
- `data`: A list of `data` groups. See <<kw_data_mod>>.
- `+zero_page`, `-zero_page`: Allocate local variables using fast zero-page RAM.

*Why do NMI interrupt functions exist?*

NMI interrupts provide a way for code to detect the vertical blanking interval (VBLANK).
This is important, as most modifications to the https://www.nesdev.org/wiki/PPU[PPU's] state
require that rendering be turned off, and VBLANK is one such time.

Since the NMI interrupt occurs once per frame, it's also convenient to use it as a timer.
Typically, game updates are run in sync with the NMI, 
as otherwise the game would speed up or slow down based on how much computation is happening.

=== `asm` [[kw_asm]]

The `asm` keyword declares an function at global scope using <<TODO_byte_block, byte block>> inline assembly syntax. 

Syntax:
----
asm fn identifier(parameters) ReturnType
: employs /groups
    vars
        local vars
    byte block
----

- `identifier` is the name of the function.
- `parameters` is a comma-separated list of variables with the syntax `Type name`.
- `ReturnType` is a type name, but is optional. Leaving `ReturnType` blank is the same as specifying it as `Void`.
- `/groups` is an optional list of groups that the function uses. See <<kw_employs>>.
- `local vars` is a line-separated list of variables with the syntax `Type name`.
- `byte block` is the <<TODO_byte_block, byte block>> of code which implements the function.

A special `default` label is required in each `asm` function,
and specifies the entry point to the function.

Example:
----
asm fn waste_time()
: employs
    vars
        U counter
    default
        lda #0
    label loop
        sta &counter
        inc &countner
        bne loop
        rts
----

*Modifiers:*

- `employs`: A list of groups. See <<kw_employs_mod>>.
- `vars`: A list of `vars` groups. See <<kw_vars_mod>>.
- `data`: A list of `data` groups. See <<kw_data_mod>>.
- `+zero_page`, `-zero_page`: Allocate local variables using fast zero-page RAM.

The labels of an `asm` function are visible using the <<TODO, `.` operator>>.
Although the address cannot be taken of these labels, it is possible to call them like functions.

Example:
----
waste_time.loop()
----

=== `struct` [[kw_struct]]

The `struct` keyword is used to define new types (https://en.wikipedia.org/wiki/Record_(computer_science)[records]) at global scope.
It behaves similarly to the `struct` keyword in other languages.

Syntax:
----
struct NewTypeName
    fields
----
- `NewTypeName` is the name of the `struct`.
- `fields` is a newline-separated list of fields, with the syntax `TypeName field_name`.

Example:
----
struct Circle
    S center_x
    S center_y
    UF radius
----

`struct` types may contain arrays and other `struct` types, 
so long as multi-dimensional arrays are not created.

Like all values in `NESFab`, `struct` types are passed by value.

=== `vars` [[kw_vars]]

The `vars` keyword declares a <<TODO_group, group>> and the global variables inside of it.

[NOTE]
All global variables belong to an associated `vars` group.
It is not possible to declare a global variable otherwise.

Syntax:
----
vars /group_name
    variables
----

- `group_name` is the name of the group that the variables will be part of.
- `variables` are global variables definitions with the syntax `TypeName identifier` or `TypeName identifier = value`.

Assigning to a global variable in a `vars` block sets its initial value.
The variable will reset to this value at the start of the program,
but also whenever a <<kw_goto_mode_statement>> occurs and the variable's group is not <<kw_preserves, preserved>>

The same group can be declared multiple times,
with each declaration defining additional global variables.
The group will be defined as the union of these declarations.

*Varibale modifiers:*

The following modifiers are per-variable, not per-group.

- `+align`: Aligns the data to fit inside a page (or to 256 bytes otherwise).
- `+zero_page`, `-zero_page`: Forces / prevents the variable from using fast zero-page RAM.

Example:
----
vars /my_group
    U score = 0 // Set an initial value for 'score'
    UU player_x
    UU player_y

vars /my_group
    U speed
----

=== `data` [[kw_data]]

The `data` keyword declares a <<TODO_group, group>> and the pointer-addressable global constants inside of it.

Syntax:
----
data /group_name
    constants
----

- `group_name` is the name of the group that the constants will be part of.
- `constants` are global constant definitions with the syntax `[optional_size] identifier`, followed by a <<TODO_byte_block, byte block>>.

The same group can be declared multiple times,
with each declaration defining additional global variables.
The group will be defined as the union of these declarations.

*Constant modifiers:*

The following modifiers are per-constant, not per-group.

- `+align`: Aligns the data to fit inside a page (or to 256 bytes otherwise).

Example:
----
data /my_group
    [4] player_speeds
        U(1)
        U(4)
        U(8)
        U(20)

    [4] player_attacks
        U(10)
        U(20)
        U(30)
        U(40)
----

=== `omni`

The `omni` keyword can be prefixed to <<kw_data>> to alter its behavior.
Groups declared using `omni` will have their data duplicated across every bank of the ROM.
Pointers to data inside this group will not include a bank field (e.g. type `CC` instead of `CCC`).

Syntax:
----
omni data /group_name
    constants
----

- `group_name` is the name of the group that the constants will be part of.
- `constants` are global constant definitions with the syntax `[optional_size] identifier`, followed by a <<TODO_byte_block, byte block>>.

*Why use `omni`?*

Data inside an `omni` block can be accessed slightly quicker, at the expense of ROM size.
Additionally, pointers to `omni` data take up only two bytes, as opposed to three.

When using a <<mappers, mapper>> without PRG banks (such as NROM), it is strictly better to use `omni data` instead of `data`.

=== `charmap`

The `charmap` keyword defines character maps,
which are sets of characters with a mapping from each character to byte values.
It is used to specify text encoding, like 
https://en.wikipedia.org/wiki/ASCII[ASCII],
https://en.wikipedia.org/wiki/EBCDIC[EBCDIC],
or https://en.wikipedia.org/wiki/MIK_(character_set)[MIK].

*Syntax:*

----
charmap identifier("string", 's')
----

- `identifier` is the name of the charmap. This is optional. When left out, the default `charmap` is defined.
- `"string"` is a string literal, defining the characters of the charmap. 
  The first character in the string will map to a value of zero, 
  with other characters mapping to one higher than the character preceding them. 
- `'s'` is ao optional charcter literal, defining the sentinel. When left out, no sentinel is defined.

*Modifiers:*

- `stows`: A `data` group. String literals using this `charmap` will place their data in this group. See <<kw_stows>>.

*Example:*

----
charmap foo(" ,.!?ABCDEFGHIJKLMNOPQRSTUVWXYZ\0", '\0')

// Defines the mapping:
// ' ' = 0
// ',' = 1
// '.' = 2
// '!' = 3
// '?' = 4
// 'A' = 5
// 'B' = 6
// 'C' = 7
// ... and so on
// with the sentinel being: '\0'
----

*Example:*

----
charmap bar("abcd")
: stows /strings

// Defines the default charmap mapping:
// 'a' = 0
// 'b' = 1
// 'c' = 2
// 'd' = 3
// with no sentinel,
// and stowing its literals in group /strings.
----

*Shared Characters*

The escape sequence `\/` has a special meaning inside of `charmap` definitions.
A charcter preceding `\/` will map to the same value as the character following it.

Commonly, `\/` is used when multiple characters can use the same glyph,
such as `0` and `O`, or `1` and `I`.

----
charmap foo("_0\/O1\/I\/|X", '\0')

// Defines the mapping:
// '_' = 0
// '0' = 1
// 'O' = 1
// '1' = 2
// '|' = 2
// 'I' = 2
// 'X' = 3
----

*Sizes and Members*

The number of unique values in a `charmap` can be accessed using the `size` member,
which is of type `Int`.

----
charmap foo("abc")

// The member 'size' is defined as:
// foo.size = 3

// Example use:
ct U last_foo_char = foo.size - 1
----

To access the members of the default `charmap`, the expression `charmap` is used:

----
// Define the default charmap:
charmap("xyz")

// Access the default charmap using 'charmap':
ct U last_default_char = charmap.size - 1
----

*Sentinels*

For `charmaps` that define a sentinel character, two things occur:

- String literals using the `charmap` have the sentinel character appended onto the end.
- The member `sentinel` of type `U` is defined for `charmap`.

The intention behind sentinel characters is to mark the end of strings.
This can be used to mimic the behavior of the C programming language's https://en.wikipedia.org/wiki/Null-terminated_string[null-terminated strings].

----
charmap foo("abc", 'b') 

// String literals have 'b' tacked on:
// "string"foo[6] = 'b'
// len("string"foo) = 7

// The member 'sentinel' is defined for 'foo':
// foo.sentinel = 1

charmap c_string("\0abc", '\0') 

// This literal is terminated by the value 0:
// "hello world"c_string

// The member 'sentinel' is defined for 'c_string':
// c_string.sentinel = 0
----

Note that sentinels must have a mapping defined in the `charmap`.
Doing so otherwise is an error.

----
charmap bad_charmap("abc", 'z') // Error! 'z' is not in the charmap!
----

*`stows` Group*

`charmap` accepts a single group in its `stows` <<modifiers, modifiers>>.
If defined, string literals using the `charmap` become valid operands to <<op_at_TODO, operator `@`>> and <<op_amper_TODO, operator `&`>>.
When using these operators, the contents of the string literal will exist in the group as data.

Example:

----
charmap foo("ABCD")
: stows /strings

// Can now reference strings using literals:
ct CCC/strings some_ptr = @"AAA"

// This is akin to defining the string inside a 'data' block first:
data /strings
    [] some_string
        ("AAA")
// ... and then referencing it:
ct CCC/strings another_ptr = @some_string
----

=== `chrrom`

The `chrrom` keyword is only used for <<mappers, mappers>> which use CHR ROM (as opposed to CHR RAM).
It specifies the data of the CHR ROM using a <<TODO, byte-block>> syntax.

Syntax:
----
chrrom
    byte block
----

Example:
----
chrrom
    file(chr, "sprites.png") 
    file(chr, "bg.png") 
----

The compiler will issue a warning if the supplied data does not match what the mapper expects.

=== `file`

=== `employs` <<kw_employs>>

The `employs` <<modifiers, modifier>> instructs a function to be dependent on a group.
From the time the function is called to the time the function returns,
the memory associated with that group will be usable by the function.

Normally, the compiler automatically infers the groups a function depends on.
The `employs` modifier is only required in these circumstances:

- A value is read or written using a hardware address (type `AA` or `AAA`).

Syntax:
----
: employs /group_names
----

- `/group_names is an optional list of groups.

=== `preserves`

The `preserves` <<modifiers, modifier>> is used inside a <<kw_goto_mode_statement>>
to specify which variables are kept, and which are reset to their initial value.

Syntax:
----
: syntax /group_names
----

- `/group_names is an optional list of `vars` groups.

If a global variable is not in a preserved group, it will be reset to its initial value if one exists.
If no initial value was specified, the value will enter an undefined (garbage) state.

=== `stows`

The `stows` <<modifiers, modifier>> is used inside `<<key_charmap>> definitions
to enable string literals to use said `charmap`.

Syntax:
----
: employs /group_name
----

- `/group_name is a single `data` group.

== Modifiers

TODO

=== Modifier Flags

- `+inline`, `-inline`: Force / prevent the function from being inlined.
- `+align`: Aligns the data to fit inside a page (or to 256 bytes otherwise).
- `+zero_page`, `-zero_page`: Force / prevent variables from using fast zero-page RAM.
- `+spr_8x16`: Reorders <<kw_file>> CHR data from 8x16 tiles to 8x8 tiles.

== Operators

=== Operator Tables

==== Unary Operators [[unary_ops]]

[NOTE]
Operators with lower precedence numbers come earlier in the order of operations.

[cols="1,1,4"]
|===
|Operator |Precedence |Description

| `@`
| 4
| <<get_pointer>>

| `&`
| 8
| <<get_hw_addr>>

| `+`
| 8
| <<unary_plus>>

| `-`
| 8
| <<unary_negate>>

| `~`
| 8
| <<unary_bitwise_not>>

| `!`
| 8
| <<unary_logical_not>>

|===


==== Binary Operators [[binop]]

[NOTE]
Operators with lower precedence numbers come earlier in the order of operations.

[cols="1,1,1,3"]
|===
|Operator |Precedence |Associativity |Description

| `.`
| 5
| Left
| <<member_access>>

| `*`
| 10
| Left
| <<multiply>>

| `+`
| 11
| Left
| <<add>>

| `-`
| 11
| Left
| <<subtract>>

| `+<-<+`
| 12
| Left
| <<rotate_left>>

| `+>->+`
| 13
| Right
| <<rotate_right>>

| `+<<+`
| 14
| Left
| <<shift_left>>

| `+>>+`
| 14
| Left
| <<shift_right>>

| `+&+`
| 15
| Left
| <<bitwise_and>>

| `+^+`
| 16
| Left
| <<bitwise_xor>>

| `+\|+`
| 17
| Left
| <<bitwise_or>>

| `+<+`
| 18
| Left
| <<less_than>>

| `+<=+`
| 18
| Left
| <<less_than_or_equal_to>>

| `+>+`
| 18
| Left
| <<greater_than>>

| `+>=+`
| 18
| Left
| <<greater_than_or_equal_to>>

| `+==+`
| 19
| Left
| <<equal_to>>

| `+!=+`
| 19
| Left
| <<not_equal_to>>

| `+&&+`
| 20
| Left
| <<logical_and>>

| `+\|\|+`
| 21
| Left
| <<logical_or>>

| `+<=<+`
| 28
| Right
| <<assign_rotate_left>>

| `+>=>+`
| 29
| Left
| <<assign_rotate_right>>

| `*=`
| 30
| Right
| <<assign_multiply>>

| `+=`
| 30
| Right
| <<assign_add>>

| `-=`
| 30
| Right
| <<assign_subtract>>

| `+<<=+`
| 30
| Right
| <<assign_shift_left>>

| `+>>=+`
| 30
| Right
| <<assign_shift_right>>

| `&=`
| 30
| Right
| <<assign_bitwise_and>>

| `^=`
| 30
| Right
| <<assign_bitwise_xor>>

| `\|=`
| 30
| Right
| <<assign_bitwise_or>>

| `=`
| 30
| Right
| <<assign>>

|===

==== Function-like Operators [[fnop]]

[NOTE]
All function-like operators have left associativity and evaluate first in the order of operations.

[cols="3,3"]
|===
|Operator |Description

| `_fn expression_(_argument expressions_...)`
| Function Call

| `_Type_(_argument expressions_...)`
| Type Cast

| `sizeof _Type_`
| Size of a Type

| `sizeof(_expression_)`
| Size of a Value

| `len _Type_`
| Array Length of a Type

| `len(_expression_)`
| Array Length of a Value

| `_array expression_[_index expression_]`
| U-Indexed Array Access

| `_array expression_{_index expression_}`
| UU-Indexed Array Access

| `[_expression_]()`
| U-Indexed Hardware Read

| `[_address expression_](_value expression_)`
| U-Indexed Hardware Write

| `{_address expression_}()`
| UU-Indexed Hardware Read

| `{_address expression_}(_value expression_)`
| UU-Indexed Hardware Write

|===

=== Operator Listings

==== Get Pointer `@` [[get_pointer]]

Converts an lvalue <<paa, pointer-addressable array>> into a corresponding pointer.

==== Get Hardware Address `&` [[get_hw_addr]]

Converts an lvalue into its corresponding hardware address, of type `AA` or `AAA`.

This operator is intended to be used with inline assembly code. 
Although this operator by itself is safe, dereferencing the addresses it returns can easily cause undefined behavior.
For regular code, it's recommended to use <<get_pointer>> instead.

==== Unary Plus `+` [[unary_plus]]

Returns its operand, type and value unchanged. The operand must be an <<arithmetic_type, arithmetic type>>.

----
+100 // Equivalent to 100
----

==== Unary Negate `-` [[unary_negate]]

Returns its operand subtracted from zero, type unchanged. The operand must be an <<arithmetic_type, arithmetic type>>.

----
-100 // Equivalent to (0 - 100)
----

==== Unary Bitwise NOT `~` [[unary_bitwise_not]]

Returns its operand with every bit flipped (1 becomes 0, and vice versa), type unchanged. The operand must be an <<arithmetic_type, arithmetic type>>.

----
U bits = %1010
~bits // Equivalent to %11110101
----

==== Unary Logical NOT `!` [[unary_logical_not]]

Returns its operand, converted to type `Bool`, then negated (`true` becomes `false` and vice versa). The operand must be an <<arithmetic_type, arithmetic type>>.

----
!0     // Equivalent to true
!5     // Equivalent to false
!true  // Equivalent to false
!false // Equivalent to true
----

==== Member Access `.` [[member_access]]

TODO

==== Multiply `*` [[multiply]]

Returns its operands multiplied together, of a type large enough to hold the product. 
The return type is signed if either operand is signed, but unsigned otherwise.
The operands must be <<quantity_type, quantity types>>.

To be more precise, if the operand types have `F` and `F'` fractional bytes, the return type will have `F + F'`.
Likewise, if the operand types have `W` and `W'` whole bytes, the return type will have `W + W'`.
The return type will be truncated to fit the compiler's available types.

----
5 * 3             // Equivalent to 15, of type Int
U(5) * U(8)       // Equivalent to 40, of type UU
UF(5.5) * SS(-10) // Equivalent to -55, of type SSSF
----

[NOTE]
Multiplying two variables together is a very slow operation,
but multiplying a variable by a constant is faster since the compiler can convert the expression to a sequence of shifts and adds.
However, if you need to do lots of multiplications, consider using lookup tables instead.

==== Assign by Multiply (`*=`) [[assign_multiply]]

Multiplies its operands together, then assigns the value to the lvalue left operand, converting as needed. 
Returns the left operand's new value.

----
U a
a *= b // Equivalent to a = U(a * b)
----

==== Add `+` [[add]]

Returns the sum of its operands. 
The operands must be of the same <<quantity_type, quantity type>>, although `Int` and `Real` will convert.

----
3 + 7 // Equivalent to 10
----

==== Assign by Add `+=` [[assign_add]]

Converts the right operand to the left operand's type, then performs an addition using both operands and assigns the value to the lvalue left operand.
Return the carry: a value of type `Bool` that is `true` when the resulting sum overflowed, and `false` otherwise. 

----
U x = 200
x += 50  // 'x' is now equal to 50. The expression returns 'false'.
x += 100 // 'x' is now equal to 94 due to overflow. The expression returns 'true'.
----

[NOTE]
Unlike in other languages, this operator doesn't return its left operand.

==== Subtract `-` [[subtract]]

Returns the difference of its operands (the right operand subtracted from the left). 
The operands must be of the same <<quantity_type, quantity type>>, although `Int` and `Real` will convert.

----
10 - 7 // Equivalent to 3
----

==== Assign by Subtract `-=` [[assign_subtract]]

Converts the right operand to the left operand's type, then performs a subtraction using both operands and assigns the value to the lvalue left operand.
Return the carry: a value of type `Bool` that is `false` when the resulting sum underflowed, and `true` otherwise. 

----
U x = 200
x -= 50  // 'x' is now equal to 150. The expression returns 'true'.
x -= 300 // 'x' is now equal to 106 due to underflow. The expression returns 'false'.
----

==== Rotate Left `+<-<+` [[rotate_left]]

Moves each of the bits of the left operand one place to the left, with the lowest bit being filled with the value of the right operand.
The left operand must be a <<quantity_type, quantity_type>>, and the right operand must be type `Bool`.
The return type matches the left operand's type.

----
U(%11001010) <-< false // Equivalent to U(%10010100)
U(%11001010) <-< true  // Equivalent to U(%10010101)
U(%01111111) <-< false // Equivalent to U(%11111110)
----

==== Assign by Rotate Left `+<=<+` [[assign_rotate_left]]

Performs a left rotation using both operands, then assigns the value to the lvalue left operand.
Returns the carry: a value of type `Bool` equal to left operand's highest bit prior to the operation.

----
U foo = %11001010
foo <=< false // Sets 'foo' to U(%10010100). Returns true.
----

==== Rotate Right `+>->+` [[rotate_right]]

Moves each of the bits of the right operand one place to the right, with the highest bit being filled with the value of the left operand.
The right operand must be a <<quantity_type, quantity_type>>, and the left operand must be type `Bool`.
The return type matches the right operand's type.

----
false >-> U(%11001010) // Equivalent to U(%01100101)
true  >-> U(%11001010) // Equivalent to U(%11100101)
false >-> U(%11111110) // Equivalent to U(%01111111)
----

[NOTE]
This operation corresponds to the 6502 assembly instruction `ROR`.

==== Assign by Rotate Right `+>=>+` [[assign_rotate_right]]

Performs a right rotation using both operands, then assigns the value to the lvalue right operand.
Returns the carry: a value of type `Bool` equal to right operand's lowest bit prior to the operation.

----
U foo = %11001010
false >=> foo // Sets 'foo' to %01100101. Returns false.
----

[NOTE]
This operator requires an lvalue on the right side of the operator, which is unlike other assignment operators.

==== Shift Left `<<` [[shift_left]]

Moves each of the bits of the left operand to the left N places, where N is the right operand of type `U`, 
and filling blank spaces with `0`.
The return type matches the left operand's type.

----
U(%11110001) << 1 // Equivalent to U(%11100010)
U(%11110001) << 3 // Equivalent to U(%10001000)
----

See: https://en.wikipedia.org/wiki/Bitwise_operation[Wikipedia on Bitwise Operations]

[NOTE]
The NES performs shifts one bit at a time, meaning `x << 1` is five times faster than `x << 5`,
and shifting by a variable (`x << y)` generates a loop in the assembly.

==== Assign by Shift Left `+<<=+` [[assign_shift_left]]

Performs a left shift using both operands, then assigns the value to the lvalue left operand.
Returns the carry: a value of type `Bool` equal to last bit shifted out (or `false` if no shifting occured).

----
U foo = %11001010
foo <<= 2 // Sets 'foo' to U(%00101000). Returns true.
----

[NOTE]
Unlike in other languages, this operator doesn't return its left operand.

==== Shift Right `>>` [[shift_right]]

Moves each of the bits of the left operand to the right N places, where N is the right operand of type `U`.
If the left operand is unsigned, the blank spaces are filled with `0`, 
otherwise the blank spaces are filled with the highest bit of the left operand (this is called sign extension).
The return type matches the left operand's type.

----
U(%11110001) >> 1 // Equivalent to U(%01111000)
S(%11110001) >> 1 // Equivalent to S(%11111000)
U(%11110001) >> 3 // Equivalent to U(%00011110)
S(%11110001) >> 3 // Equivalent to S(%11111110)
S(%01110001) >> 3 // Equivalent to S(%00001110)
----

See: https://en.wikipedia.org/wiki/Bitwise_operation[Wikipedia on Bitwise Operations]

[NOTE]
The NES performs shifts one bit at a time, meaning `x >> 1` is five times faster than `x >> 5`,
and shifting by a variable (`x >> y)` generates a loop in the assembly.

==== Assign by Shift Right `+>>=+` [[assign_shift_right]]

Performs a right shift using both operands, then assigns the value to the lvalue left operand.
Returns the carry: a value of type `Bool` equal to last bit shifted out (or `false` if no shifting occured).

----
U foo = %11001010
foo >>= 2 // Sets 'foo' to U(%00110010). Returns true.
----

[NOTE]
Unlike in other languages, this operator doesn't return its left operand.

==== Bitwise AND `&` [[bitwise_and]]

Applies the AND operation across each bit of the operands, returning the result.
The operands must be of the same <<arithmetic_type, arithmetic type>>, although `Int` and `Real` will convert.

----
U(%11110000) & U(%10101010) // Equivalent to U(%10100000)
----

See: https://en.wikipedia.org/wiki/Bitwise_operation[Wikipedia on Bitwise Operations]

==== Assign by Bitwise AND `&=` [[assign_bitwise_and]]

Converts the right operand to the left operand's type, then performs a bitwise AND using both operands and assigns the value to the lvalue left operand.
Returns the left operand's new value.

----
U foo = %11110000
foo &= %10101010 // Sets 'foo' to U(%10100000)
----

==== Bitwise XOR `^` [[bitwise_xor]]

Applies the XOR operation across each bit of the operands, returning the result.
The operands must be of the same <<arithmetic_type, arithmetic type>>, although `Int` and `Real` will convert.

----
U(%11110000) ^ U(%10101010) // Equivalent to U(%01011010)
----

See: https://en.wikipedia.org/wiki/Bitwise_operation[Wikipedia on Bitwise Operations]

==== Assign by Bitwise XOR `^=` [[assign_bitwise_xor]]

Converts the right operand to the left operand's type, then performs a bitwise XOR using both operands and assigns the value to the lvalue left operand.
Returns the left operand's new value.

----
U foo = %11110000
foo ^= %10101010 // Sets 'foo' to U(%01011010)
----

==== Bitwise OR `|` [[bitwise_or]]

Applies the OR operation across each bit of the operands, returning the result.
The operands must be of the same <<arithmetic_type, arithmetic type>>, although `Int` and `Real` will convert.

----
U(%11110000) | U(%10101010) // Equivalent to U(%11111010)
----

See: https://en.wikipedia.org/wiki/Bitwise_operation[Wikipedia on Bitwise Operations]

==== Assign by Bitwise OR `|=` [[assign_bitwise_or]]

Converts the right operand to the left operand's type, then performs a bitwise OR using both operands and assigns the value to the lvalue left operand.
Returns the left operand's new value.

----
U foo = %11110000
foo |= %10101010 // Sets 'foo' to U(%11111010)
----

==== Logical AND `&&` [[logical_and]]

Implements the https://en.wikipedia.org/wiki/Short-circuit_evaluation["short-circuit"] version of the AND operation from boolean logic.

Evaluates the left operand and converts it to `Bool`. If it is `false`, the operator returns `false`. 
Otherwise, it evaluates the right operand and returns its value converted to `Bool`.

----
false && false  // Returns false
true  && false  // Returns false
false && true   // Returns false
true  && true   // Returns true
----

==== Logical OR `||` [[logical_or]]

Implements the https://en.wikipedia.org/wiki/Short-circuit_evaluation["short-circuit"] version of the OR operation from boolean logic.

Evaluates the left operand and converts it to `Bool`. If it is `true`, the operator returns `true`. 
Otherwise, it evaluates the right operand and returns its value converted to `Bool`.

----
false || false  // Returns false
true  || false  // Returns true
false || true   // Returns true
true  || true   // Returns true
----

==== Less Than `<` [[less_than]]

Compares the <<arithmetic_type, arithmetic type>> operands, returning `true` if the left operand is less than the right and `false` otherwise.
The operands may be of different types. No types conversions occur besides `Int` and `Real` conversions.

----
3 <  10 // Returns true
3 < -10 // Returns false
----

==== Less Than or Equal To `+<=+` [[less_than_or_equal_to]]

Compares the <<arithmetic_type, arithmetic type>> operands, returning `true` if the left operand is less than or equal to the right and `false` otherwise.
The operands may be of different types. No types conversions occur besides `Int` and `Real` conversions.

----
3 <= 3   // Returns true
3 <= -10 // Returns false
----

==== Greater Than `>` [[greater_than]]

Compares the <<arithmetic_type, arithmetic type>> operands, returning `true` if the left operand is greater than the right and `false` otherwise.
The operands may be of different types. No types conversions occur besides `Int` and `Real` conversions.

----
3 >  10 // Returns false
3 > -10 // Returns true
----

==== Greater Than or Equal To `>=` [[greater_than_or_equal_to]]

Compares the <<arithmetic_type, arithmetic type>> operands, returning `true` if the left operand is greater than or equal to the right and `false` otherwise.
The operands may be of different types. No types conversions occur besides `Int` and `Real` conversions.

----
3 >= 3  // Returns true
3 >= 10 // Returns false
----

==== Equal To `==` [[equal_to]]

Compares the <<arithmetic_type, arithmetic type>> operands, returning `true` if the left operand is equal to the right and `false` otherwise.
The operands may be of different types. No types conversions occur besides `Int` and `Real` conversions.

----
3 == 3  // Returns true
3 == 10 // Returns false
----

==== Not Equal To `!=` [[not_equal_to]]

Compares the <<arithmetic_type, arithmetic type>> operands, returning `true` if the left operand is equal to the right and `false` otherwise.
The operands may be of different types. No types conversions occur besides `Int` and `Real` conversions.

----
3 != 3  // Returns false
3 != 10 // Returns true
----

==== Assign `=` [[assign]]

Stores the right operand into the left and returns the new value of the left operand.
The right operand must have the same type as the left operand, although `Int` and `Real` will convert.

----
U foo
foo = 10 // 'foo' is now equal to 10
----

=== Arithmetic Type [[arithmetic_type]]
=== Quantity Type [[quantity_type]]
=== PAA [[paa]]



=== Explicit Type Casts [[casts]]

Type casts convert values into different types.

Basic syntax:
----
Type(value)
----
Where `type` is any type name, and `value` is any expression.

Example:

----
fn example()
    U some_u = 10
    SS some_ss = SS(some_u)    // An explicit cast to SS
    UUF some_uuf = UUF(some_u) // An explicit cast to UUF
----

==== Zero Initializations

A type cast with no arguments is called a zero initialization.
The value, its struct members, and its array elements are initialized to zero.

----
U()          // equivalent to U(0)
UF()         // equivalent to U(0.0)
U[3]()       // equivalent to U[3](0, 0, 0)
SomeStruct() // equivalent to SomeStruct(0, 0)
----

==== Array Fills

Array fills are used to create arrays where every element holds identical values.
They are specified as an array cast, where the cast's singular argument can be converted to the element type.

----
S[2](50) // equivalent to S[2](50, 50)
U[5](11) // equivalent to U[5](11, 11, 11, 11, 11)
----

=== Comments

NESFab supports two kinds of https://en.wikipedia.org/wiki/Comment_(computer_programming)[comments]: single-line and multi-line.

==== Single-Line Comments

Single-line comments begin with the character sequence `//`, and terminate at the end of the line.

----
// This is a single-line comment.

ct U foo = 10 // You can put them after lines of code to document it.
----

==== Multi-Line Comments

Multi-line comments begin with the character sequence `/\*` on a new line, and terminate with the character sequence `*/`, followed by a line ending.

[NOTE]
Unlike other languages, multi-line comments cannot share lines with code.

----
/*
   This is a multi-line
   comment!
*/

/* This is also a 
   multi-line comment! */

ct U foo = 10 /* This won't compile. 
Multi-line comments cannot share lines with code. */

/*
   This won't compile.
   Multi-line comments cannot share lines with code.
*/ ct U foo = 10
----

=== Indentation

Indentation refers to the spaces at the beginning of each line.
In NESFab, indentation is significant and alters the behavior of code.

Indentation is used to create **code blocks**, where every line but the first is indented using spaces (not tabs).
The amount of spaces is up to you, but it must be consistent throughout the block.
----
FIRST LINE
    INDENTED LINE
    INDENTED LINE
    INDENTED LINE
----
*Code blocks* can be nested:
----
FIRST BLOCK
    INDENTED LINE
    INDENTED LINE
    SECOND BLOCK
        INDENTED LINE
        INDENTED LINE
    THIRD BLOCK
        INDENTED LINE
        INDENTED LINE

----

The meaning of the indentation is determined by the first line - it might be a construct like `if` or `else`, 
a definition like a function, or something else.

=== Top Level

=== Values and Types

Some text

=== Boolean Literals

There are two boolean literals:

- `true`
- `false`

Boolean literals have the type `Bool`.

=== Numeric Literals

Numeric literals can be either decimal, hexadecimal, or or binary. Hexadecimal literals are prefixed with a `$` character, while binary with `%`:

----
1234  // Decimal
$89AB // Hexadecimal
%1010 // Binary
----

Literals can use decimal points:

----
12.34  // Decimal
$.89AB // Hexadecimal
%1010. // Binary
----

Literals with decimal points have the type `Real`, while those without are `Int`.

=== String and Character Literals

==== Syntax and Semantics

Basic syntax:

----
'c'   // Character using the default charmap
"NES" // Uncompressed string using the default charmap
`NES` // Compressed string using the default charmap

'c'some_charmap   // Character using a specific charmap
"NES"some_charmap // Uncompressed string using a specific charmap
`NES`some_charmap // Compressed string using a specific charmap
----

Character literals have the type `U`. String literals have the type `U[N]`, where `N` is the length of the string.

Each string and character literal uses a `charmap` 
to translate the characters from Unicode into the `charmap`'s range.
The `charmap` is set by an identifier following the literal.
If no identifier follows, the default `charmap` is used.

Strings can be uncompressed or compressed. 
Compressed strings use a https://en.wikipedia.org/wiki/Byte_pair_encoding[byte-pair encoding], 
where unused values in the charmap represent pairs of bytes.
These pairs are expanded recursively to decompress the string.

The nice thing about byte-pair encoding is that uncompressed strings are valid under the encoding too.
This means functions for compressed strings also work with uncompressed strings.

TODO: explain how to use.


==== Escape Sequences

Escape sequences denote characters that are either impossible or unwiedly to write otherwise.
Every escape sequence begins with backslash character `\`, followed by one or more characters.

For example, to denote the apostrophe character, you must use an escape sequence, as `'''` is not valid syntax.
Likewise, to write a string containing line breaks, you must use escape sequences.

----
'\''            // An apostrophe character literal
"Hello\nWorld!" // A multi-line string literal
----

The valid escape sequences are listed below.

[cols="1,1,2"]
|===
|Escape Sequence |Unicode Code Point |Description

|`\0`
|$00
| Sentinel

|`\a`
|$07
| Bell or alert

|`\b`
|$08
| Backspace

|`\t`
|$09
| Tab

|`\n`
|$0A
| Newline

|`\v`
|$0B
| Vertical tab

|`\f`
|$0C
| Form feed

|`\r`
|$0D
| Carriage return

|`\"`
|$22
| Quotation mark

|`\'`
|$27
| Apostrophe

|`\\`
|$5C
| Backslash

|`\``
|$60
| Backtick

|`\/`
|$FFFFFFFF
| Special meaning for `charmap` definitions
|===

Unicode code points can also be specified directly. Below, each N character represents any hexadecimal digit.

[cols="1,1"]
|===
|Escape Sequence |Unicode Code Point

|`\xNN`
|$NN

|`\uNNNN`
|$NNNN

|`\UNNNNNNNN`
|$NNNNNNNN
|===


== Types

=== Scalar Types

==== Integer Types

Unsigned integer types are expressed using the character `U`, while signed integer types use `S`.
The values of signed integers are expressed in https://en.wikipedia.org/wiki/Two%27s_complement[two's complement] form.

The 6 integer types are listed below.

[cols="1,1,1"]
|===
|Type |Size (bytes) |Value range

|`U`
|1
|[0, 255]

|`S`
|1
|[-128, 127]

|`UU`
|2
|[0, 65535]

|`SS`
|2
|[-32768, 32767]

|`UUU`
|3
|[0, 16777215]

|`SSS`
|3
|[-8388608, 8388607]
|===

==== Unit-Fractional Types
[cols="1,1,1"]
|===
|Type |Size (bytes) |Value range

|`F`
|1
|[$0.00, $0.FF]

|`FF`
|2
|[$0.0000, $0.FFFF]

|`FFF`
|3
|[$0.000000, $0.FFFFFF]
|===

==== Fixed-point Types

An integer type and a unit-fractional type can be combined to form a fixed-point type, merging the ranges of both.
The syntax is the integer type, followed by the unit-fractional type, without no other characters in-between.

*There are 18 possible fixed-point types, but only 3 are listed below.* The rest can be inferred from the tables above.

[cols="1,1,1"]
|===
|Type |Size (bytes) |Value range

|`UF`
|1
|[$00.00, $FF.FF]

|`SSF`
|3
|[-$8000.00, $7FFF.FF]

|`UFFF`
|4
|[$00.000000, $FF.FFFFFF]
|===

==== Numeric Constant Types

`Int` and `Real` are used for compile-time constants.

Literal expressions denoting integers, like `1234` or `$40`, have the type `Int`.
Likewise, literal expressions with a `.` to denote fractions, like `3.14`, `0.5`, or `100.0`, have the type `Real`.

Values of these types can only exist at compile-time. 
Any attempt to use them at run-time will error.

[cols="1,1,1"]
|===
|Type |Size (bytes) |Value range

|`Int`
|4
|[-2147483648, 2147483647]

|`Real`
|7
|[-$80000000.000000, $7FFFFFFF.FFFFFF]
|===

In many cases, `Int` and `Real` implicitly convert to other numeric types based on context.
For example, when using `Int` or `Real` in an operator like `+`, 
the value converts to match the other operand's type.

----
U(a) + Int(b) // 'b' will implicitly convert to type U.
----

When converting `Real` to a smaller representation, the value will be rounded.
This is in contrast to other type conversions, which truncate.
The purpose of this rounding is to improve the accuracy of `Real` constants.

----
U x = U(1.75)     // 'x' is set to 2 via rounding, NOT 1.
U x = U(UF(1.75)) // 'x' is set to 1 via truncation, NOT 2.
----

Although `Int` and `Real` cannot be used at run-time, 
it is very useful to use them at compile-time.
For example, you may use them to define numeric constants:

----
ct Int MEANING_OF_LIFE = 42
ct Real PI = 3.14159265359 
ct Real GOLDEN_RATIO= 1.61803398875
----

==== Bool

The type `Bool` is short for "boolean", and represents the values `true` and `false`.

[cols="1,1,1"]
|===
|Type |Size (bytes) |Value range

| `Bool`
| 1
| [`false`, `true`]
|===

The `Bool` type is space-inefficient, as each value takes a byte if stored in memory.
If you need lots of boolean values, it's recommended to combine them into bit-field flags using an integer type:

----
ct U IS_ALIVE  = 1 << 0
ct U IS_MOVING = 1 << 1
ct U IS_HAPPY  = 1 << 2

fn example()
    U flags = 0
    flags |= IS_ALIVE   // set flags
    flags &= ~IS_MOVING // clear flags
    if flags & IS_HAPPY // test flags
        // . . .
----

==== Void

The type `Void` represents no value. 
Its purpose is to represent the return type of functions that return no value.

Note that you do not have to use the `Void` keyword, 
as leaving the return type off of a function implies `Void`.

[cols="1,1,1"]
|===
|Type |Size (bytes) |Value range

| `Void`
| 0
| N/A
|===

==== Pointer Types

TODO

==== Address Types

The address type `AA` is used for 16-bit hardware addresses, 
and has the same representation as pointers, ignoring groups.
This type is used for inline assembly and hardware expressions.

`AAA` behaves like `AA`, but has an additional byte which tracks the address's bank.

[cols="1,1,1"]
|===
|Type |Size (bytes) |Value range

| `AA`
| 2
| [$0000, $FFFF]

| `AAA`
| 3
| [$00:$0000, $FF:$FFFF]

|===

When serializing, the bank byte comes TODO after? before?

TODO

=== Arrays

NESFab has two kinds of https://en.wikipedia.org/wiki/Array_(data_structure)[array] types with different restrictions for each.
The first has value semantics and behaves like arrays do in other languages, but cannot be referenced by pointers. 
The second can, but it very limited otherwise and can only represent elements of type U.

==== Typed Element Arrays (TEAs)

A TEA is an array of a specified type, of any size between 1 and 65536. Two TEA variables are shown below.

----
fn example()
    // Syntax is TYPE[SIZE]
    UU[10] a_tea_variable
    SomeStruct[1500] another_tea_variable
----

At the type level, TEAs are strictly one-dimensional.
That is, one cannot have a TEA of a TEA.
The compiler will enforce this even if TEAs are hidden inside structs.

----
struct SomeStruct
    U[30] struct_tea

fn foo()
    U[10][20]      // Error! Can't have multi-dimensional TEAs
    SomeStruct[50] // Error! Can't have multi-dimensional TEAs
----

A TEA value can be created using a cast. 
The size can be left blank and the compiler will infer it.

----
fn example()
    U[3] small_tea = U[3](10, 20, 30) // Initialize with value
    U[] inferred_tea = U[](3, 1, 4)   // Inferred size
----

TEAs are always copied by value.
To copy more or fewer elements, the TEA can be cast to a different size before copying.
When casting to a larger TEA, the new elements at the end of the TEA are zero-initialized.

----
fn example()
    U[3] small_tea = U[3](10, 20, 30)
    U[3] copied_tea = small_array
    U[2] smaller_tea = U[2](small_tea)
    U[5] larger_tea  = U[5](small_tea)
----


Operator `[]` or operator `{}` can be used to read or write the elements of a TEA value. 
The indexing is zero-based.

- `[]` expects an index argument of type `U`, limiting it to the first 256 elements.
- `{}` expects an index argument of type `UU`.

----
fn example()
    UU[1500] a_tea_variable
    a_tea_variable[4] = 64   // Set the 5th element to 64.
    a_tea_variable{999} = 10 // Set the 1000th element to 10.
    a_tea_variable[999] = 10 // Error! 999 can't convert to type U.
----

The rationale for two different indexing operators is performance; 
in general, `[]` executes significantly faster than `{}`, 
as the NES only supports 8-bit indexing natively.

Note that in some cases, the compiler will be able to optimize operator `{}` to take advantage of 8-bit indexing on the NES's hardware.
One such pattern it recognizes is:

----
tea{U(index) + CONSTANT}
----

But in general, one should prefer to use `[]`, with TEAs of size 256 or less.

==== Pointer-Addressable Arrays (PAAs)

PAAs only support a single element type: `U`, and can only be defined at global scope. 
Like TEAs, they can be any size from 1 to 65536.

----
vars /example
    // Syntax is [SIZE]
    // (You do not specify a type, as it is always type U)
    [10] a_paa
    [1500] another_paa

fn example([100] bad_param) // Error! Cannot use PAAs as fn parameters
    [100] bad_variable      // Error! Cannot use PAAs as local variables
----

PAAs cannot be created using casts and there is no support for copying them.

Like TEAs, operator `[]` or operator `{}` can be used to read or write the elements of a TEA value. 
The indexing is zero-based.

- `[]` expects an index argument of type `U`, limiting it to the first 256 elements.
- `{}` expects an index argument of type `UU`.

----
vars /example
    [10] a_paa

fn example()
    MM/example ptr = @a_paa // Get a pointer to 'a_paa'
----

=== Structures

Structures (or "structs"), 

           TODO

== TODO

=== TODO

==== fn keyword [[fn]]

`fn` is used to define functions.

==== ct keyword [[ct]]
=== Modifiers [[modifiers]]

TODO





Example usage:

----
// A charmap of decimal digits:
charmap foo("0123456789")

// A charmap of uppercase letters, a few punctuation marks, with a sentinel:
charmap bar(" ,.!ABCDEFGHIJKLMNOPQRSTUVWXZY\0", '\0)
----

Following the `charmap` keyword, 

ASCII, EBDIC, 
https://en.wikipedia.org/wiki/MIK_(character_set)
A character is a [https://en.wikipedia.org/wiki/Unicode[Unicode] code point.
This 

On modern systems, 
a format like  or https://en.wikipedia.org/wiki/Unicode[Unicode] 
is used to encode text,
but these are undesirable on simpler systems like the NES.

== Second section

More test
